자료구조란?
컴퓨터에 자료를 효율적으로 저장하는 방식.

자료구조의 목적 
-프로그램에서 사용하는 메모리를 절약하기 위해서
-프로그램 실행 시간을 단축하기 위해서
-프로그램의 구현을 쉽게 하기 위해서

자료구조의 분류 
-선형 구조 linear data structure
-비선형 구조(non linear data structure)
-단순 구조(simple structure)
-파일 구조 (file structure)

선형 구조란?
-여러개의 자료를 한 줄로 순서대로 저장하는 구조
-자료들 사이의 앞뒤 관계가 일대일(1:1)
-리스트(list), 스택(stack), 큐(queue)가 있다.

비선형 구조란?
-각각의 자료들 사이의 앞뒤 관계가 일대일(1:1)이 아닐 
수 있다.
-트리, 힙, 그래프가 있다.

단순 구조란?
-프로그램 언어에서 제공하는 기본적인 자료형(data type)
-정수(int), 실수(double, float) 문자(char)등이 있다.

파일 구조란?
-보조기억 장치에 저장되는 파일의 자료 구조
-메모리에 한번에 올릴 수 없는 대용량을 다룸
-순차적 파일구조(sequential file structure),
 색인 파일구조 


배열이란? 
다수의 데이터를 그룹핑해서 효율적으로 관리할 수 있는 데이터
스트럭처 입니다. 배열의 가장 큰 특징은 인덱스가 있다는 것 
만약 인덱스를 알고 있다면 인덱스를 이용해서 데이터를 가져올 수 있다. 인덱서를 이용한 데이터의 조회는 매우 빠르게 처리 됨
but 인덱스를 이용해서 데이터를 가져오려면 데이터에 대한 
인덱스의 값이 고정되어야 함 
자연스럽게 어떤 엘리먼트가 삭제되면 삭제된 상태를 빈 공간으로 남겨둬야 함 
이것은 메모리의 낭비를 초래 또한 배열에 데이터가 있는지
없는지를 체크하는 로직이 필요하다는 의미 

리스트란?
자료를 순서대로 저장하는 자료구조.
선형구조임

리스트 종류 
- 배열 리스트
- 연결 리스트

배열 리스트란?
- 배열을 사용해서 구현된 리스트
- '물리적으로 연속해 있는' 배열을 사용하여 '논리적으로 연속해    있는' 리스트를 구현한 것.

배열 리스트의 장점
물리적 주소를 바로 계산할 수 있기 때문에 특정 위치에
바로 접근할 수 있음

배열 리스트의 단점
- 배열의 길이는 정해져 있음
- 삽입이나 삭제 시 데이터의 이동 및 복사가 자주 일어나며
  저장 범위를 넘어설 수 있음.

리스트는 배열이 가지고 있는 인덱스라는 장점을 버리고 대신
빈틈없는 데이터의 적재라는 장점을 취한 데이터 스트럭쳐라고
할 수 있다.



리스트에서는 인덱스 중요x 
리스트 데이터 스트럭처의 핵심은 엘리먼트들 간의 순서 
그래서 리스트를 다른 말로는 시퀀스(sequence)라고도 부름 
시퀀스는 순서라는 의미 . 즉 순서가 있는 데이터의 모임이 리스트

리스트의 기능 
리스트의 핵심적인 개념은 순서가 있는 엘리먼트의 모임이라는 것 빈 엘리먼트는 허용되지 않는다는 것도 기억해야 함 
그리고 중복된 데이터도 허용함, 중복 허용은 배열과 리스트의 차이가 아니다. 배열도 중복이 허용됨. 중복 허용은 set과 같은 데이터 스트럭처와의 차이라고 할 수 있다.

리스트 데이터 스트럭쳐는 아래와 같은 기능을 가지고 있다.
-처음, 끝, 중간에 엘리먼트를 추가/삭제하는 기능 
-리스트에 데이터가 있는지를 체크하는 기능
-리스트의 모든 데이터에 접근할 수 있는 기능

위와 같은 기능을 가지고 있고, 순서가 있으면 중복이 허용된다면 
그러한 데이터 스트럭처를 리스트라고 한다.

내장된 리스트
리스트를 직접 구현하는 것도 좋지만, 자신이 사용하고 있는 언어에 이미 리스트가 내장되어 있다면 그것을 사용해야 한다.
많은 사람에 의해서 검증되었을 것이고 속도도 빠르기 떄문 

모든 언어가 리스트를 내장하고 있는건 아니다.

자바스크립트의 경우는 배열에 리스트의 기능을 포함하고 있다.
인덱스 3인 엘리먼트를 삭제하고 싶을때는?

numbers = [10, 20, 30, 40, 50];
// 인덱스 3을 제거 
numbers.splice(3,1);
for(i = 0; i < numbers.length; i++) {
 console.log(numbers[i]);
}

결과
10
20
30
50

즉 자바스크립트의 배열은 리스트의 기능도 포함하고 있는 것이라고 할 수 있다. 만약 각각의 엘리먼트가 고유한 인덱스를 가지고 있게 하려면 splice 대신에 number[3] = null; 과 같은 방법을 사용하면 된다. 즉 배열을 어떻게 이용하는냐에 따라서 배열이 될 수 도 있고 리스트가 될 수도 있따.

파이썬은 자바스크립트와 비슷한 방법으로 리스트를 지원함 .
그런데 파이썬에는 배열은 없고 리스트만 있다.
동일한 코드 파이썬으로 작성 
기능은 자바스크립트의 배열과 같지만 이름이 리스트인 것이다.

numbers = [10, 20, 30, 40, 50];
numbers.pop[3];
for number in numbers;
	pint(number);
실행결과는  자스랑 같다
10
20
30
50

자바스크립트나 파이썬과 같은 언어를 스크립트 언어라고 부른다.
이런 언어들이 추구하는 가치는 '쉽다' 이다.
개발자들이 자주 사용하는 기능인 리스트를 언어에 포함해서 
쉽게 사용할 수 있도록 배려하는 것이다.

자바에서의 리스트 
자바의 경우 배열과 리스트를 모두 개별적으로 지원한다.
int[] numbers = {10,20,30,40,50);
String[]은 변수 numbers가 문자열을 엘리먼트로 하는 배열임을 의미한다.
자바에서 배열의 원소를 제거하는 것은 쉬운일이 아니다.
자바스크립트의 splice 파이썬의 pop같은 기능을 제공하지 않기 떄문이다. 직접 구현해야 한다.

대신 자바에서는 리스트라는 이름의 데이터 스트럭쳐를 지원한다.

ArrayList numbers = new ArrayList();
numbers.add(10);
numbers.add(20);

자바는 스크립트 언어들과는 다른길을 간다. 
스크립트 언어의 핵심 미덕은'쉽다'이다. 배열과 리스트를 지원하면서도 사용자들이 기억해야 할 것을 줄이기 위해서 둘을 융합하는 선택을 했다.

하지만 자바는 개발자가 배열과 리스트 중에 자신의 상황에 맞는선택을 분명하게 선택할 수 있도록 이것들을 별도의 기능으로 지원하고 있다.

왜 자바에서는? 하나의 리스트를 지원하지 x LinkedList와 ArrayList를 둘다 지원하는 이유는 무엇일까?
이것을 이해하기 위해서는 LinkedList와 ArrayList의 구현방법을 이해해야 한다. 
결론적으로 말하면 인덱스를 이용해서 데이터를 가져오는 것이 빈번하다면 ArrayList가 훨씬 빠르다.
하지만 데이터의 추가/삭제가 빈번하다면 LinkedList가 훨씬 효과적이다. 
	  데이터 추가/삭제                 인덱스 조회
ArrayList       느림 			      빠른편 
LinkedList     빠름                                 느린편

ArrayList는 배열을 이용해서 리스트를 구현한 것을 의미함 
장점은 내부적으로 배열을 이용하기 떄문에 인덱스를 이용해서 
접근하는 것이 빠르다. 하지만 데이터의 추가 삭제는 느리다.

데이터의 추가 
ArrayList는 내부적으로 데이터를 배열에 저장함. 배열의 특성상 데이터를 리스트의 처음이나 중간에 저장하면 이후의 데이터들이 한칸씩 뒤로 물러나야 한다.

데이터의 삭제 
삭제도 추가와 비슷하다. 빈자리가 생기면 빈자리를 채우기 위해서 순차적으로 한칸씩 땡겨야 함

데이터를 가져오기 
인덱스를 이용해서 데이터를 가져오고 싶을 때 Array로 구현한 리스트는 매우 빠르다. 메모리 상의 주소를 정확하게 참조해서 가져오기 때문이다.

배열을 건물에 비유해보면. 각각의 엘리먼트는 그 엘리먼트에 대한 인덱스를 가지고 있다. 인덱스를 안다는 것은 주소를 알고 있는것과 같다. 반면에 인덱스를 모르는 것은 주소를 모르고 집을 찾아가는 것과 같기 때문에 시간이 오래 걸린다.
인덱스만 알고 있다면 Array list에서 데이터를 가져오는 것은 매우 빠르다.

Java에서 ArrayList는 가장 많이 사용되는 데이터 스트럭처이다.
특히 자바의 배열은 동일한 데이터 타입의 엘리먼트만 담을 수 있고 크기가 고정되어 있기 떄문에 사용하기 까다롭다.

class Ideone {
	
	public static void main(String[] args) throws java.lang.Exception; {
	
	ArrayList<Integer> number = new ArrayList<>();
	number.add(10);
	number.add(20);
	number.add(30);
	number.add(40);
	System.out.println("add(값)");
	System.out.println(numbers;)

	lliterator<Integer> it = numbers.iterator();
	System.out.println("\niterator");
	while(it.hasNext()) {
	int value = it.next();
	if(value == 30) {
		it.remove();	
	}
	}
	System.out.println(numbers);
	
	System.out.println("\nfor each");
	for(int value : numbers) {
		System.out.println(value);



ArrayList를 사용하기 위해서는 우선 ArrayList 객체를 만들어야 함
ArrayList<> numbers = new ArrayList<>();
numbers.add(10);
numbers.add(20);
numbers.add(30);
	}
}
엘리먼트를 추가 할 떄는 add메소드를 사용함 
add는 배열에 단순히 더해지는 것이기 때문에 빠르게 동작함

특정 위치에 추가하고 싶다면 메소드 add의 첫번쨰 인자로 
인덱스를 지정한다.

numbers.add(1,50);

자바의 배열은 크기가 고정되어 있다. 데이터를 추가하는 과정에서 내부적으로 사용하는 배열이 꽉차면 기존의 배열 대비 크기가 2배 큰 새로운 배열을 만들고 기존의 데이터를 새로운 배열로 복제한다. 
덕분에 프로그래머는 ArrayList의 크기에 신경쓰지 않고 편리하게 프로그램을 만들 수 있다. 하지만 배열의 크기를 키우는 과정에서 많은 부하가 발생한다. 

엘리먼트를 가져올 떄는 get을 사용한다.
number.get(2)
이떄 내부적으로 배열을 이용하기 떄문에 매우 빠르게 엘리먼트를 가져올 수 있다. 

자바에서는 ArrayList를 탐색하기 위한 방법으로 iterator을 제공한다. 이것은 주로 객체지향 프로그래밍에서 사용하는 반복기법이다. 
우선 lterator 객체를 만들어야 한다.

lterator it<Integer>  = numbers.iterator();

lterator 객체는 numbers 객체 내부에 저장된 값을 하나씩 순회하면서 탐색할 수 있도록 돕는 객체이다.
while(it.hasNext()) {
	System.out.println(it.next());
}
it.next()메소드를 호출할 떄마다 엘리먼트를 순서대로 리턴한다.
만약 더 이상 순회할 엘리먼트가 없다면
it.hasNext()의 값은 false가 되면서 while문이 종료된다.
단순 출력을 위해서 순회는 하지 않겠지?
순회과정에서 필요에 따라서는 엘리먼트를 삭제/추가하는 작업을 해야 할 것이다. 그런 경우 아래와 같이 처리할 수 있다.

while(it.hasNext()) {
	int value = it.next();
	if(value == 30) {
		it.remove();
	}
}

객체생성
우선 ArrayList라는 이름의 객체를 만든다.
ArrayList.java

public class ArrayList {
	private int size = 0;
	private object[] elementData = new Object[100];	
}

Man.java

pulbic class Man {

	public static void main(String[] args) {

	ArrayList numbers = new ArrayList();
	}
}

데이터를 중간에 추가하는 로직은 조금 더 복잡하다.
데이터를 추가할 빈공간을 확보해야 하기 떄문 

public boolean add(int index, object element) {
	// 엘리먼트 중간에 데이터를 추가하기 위해서는 끝의
	엘리먼트부터 index의 노드까지
	for(int i = size -1; i >= index; i--) {
	elementData[i + 1] = elementData[i];
	}
	// index에 노드를 추가한다.
	elementData[index] = element;
	//엘리먼트의 숫자를 1 증가 시킨다.
	size++;
}
}

데이터를 확인하기 위해서 toString 객체를 상속해서 구현 
public String toString() {
	String str = "[";
	for(int i = 0; i < size; i++) {
	str += elementData[i];
	if(i < size-1) {
	str += ",";
	}

	}
	return str + "]";
}





















출처 : 생활코딩
