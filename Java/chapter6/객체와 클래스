메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다.

자바에서는 설계도가 바로 클래스이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.
클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다. 
자동차 객체는 자동차 클래스의 인스턴스인 셈이다. 
그리고 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다. 하나의 클래스로부터 여러개의 인스턴스를 만들 수 있다.

객체 지향 프로그래밍 개발은 세 가지 단계가 있다.
첫 번째 단계 -> 클래스를 설계해야 한다.
두 번째 단계 -> 설계된 클래스를 가지고 사용할 객체를 생성해야 한다. 
마지막 단계 -> 생성된 객체를 이용하는 것이다. 

클래스 이름이 단일 단어라면 첫 자를 대문자로 하고 나머지는 소문자로 작성한다. 만약 서로 다른 단어가 혼합된 이름을 사용한다면
각 단어의 첫 머리 글자는 대문자로 작성하는 것이 관례이다.

public class 키워드는 클래스를 선언할 때 사용하며 반드시 소문자로 작성해야 한다.

public class 클래스이름 {

}클래스 이름 뒤에는 반드시 중괄호 {}를 붙여주는데, 중괄호 시작은{은 클래스 선언의 시작을 알려주고 }은 클래스 선언의 끝을 알려준다.

public class Car {}  Car 클래스 선언 
일반적으로 소스 파일당 하나의 클래스를 선언한다. 하지만, 두개 이상의 클래스 선언도 가능하다.

public class Car{} 

class Tire {} 
// 두개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일은(.class) 클래스를 선언한 개수만큼 생긴다. 
결국 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다. 
주의할 점은 파일이름과 동일한 이름의 클래스 선언에만 public 접근제한자를 붙일 수 있다. 

ㅁ객체 생성과 클래스 변수 
클래스를 선언한 다음, 컴파일을 했다면 객체를 생성할 설계도가 만들어진 셈이다. 
클래스로부터 객체를 생성하는 방법은 다음과 같이 new 연산자를 사용하면 된다.
new는 클래스로부터 객체를 생성시키는 연산자이다. new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.

new 연산자로 생성된 객체는 메모리 힙(hear) 영역에 생성된다. 
현실세계에서 물건의 위치를 모르면 물건을 사용할 수 없듯이, 객체지향 프로그램에서도 메모리 내에서 생성된 객체의 위치를 모르면 객체를
사용할 수 없다. 그래서 new 연산자는 힙영역에 객체를 생성시킨 후 , 객체의 주소를 리턴하도록 되어 있다.
이 주소를 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다. 

클래스 변수; // 클래스 변수 선언
변수 = new 클래스(); // 클래스 변수에 new 연산자를 통해 객체를 만들고  객체의 주소를 변수에 저장 

클래스 변수 선언과 객체 생성을 한개의 실행문으로
-->  클래스 변수 = new 클래스();

이렇게 new 연산자로 객체를 생성하고 리턴된 객체의 주소를 변수에 저장하면 변수가 객체를 참조하게 된다. 

클래스 선언
public class StudyPlan{} 

클래스로부터 객체 생성

StudyPlan studyplan = new StudyPlan(); // 클래스 변수 선언과 객체 생성 
// studyplan 변수가 StudyPlan 객체를 참조 합니다. 

이렇게 하면 메모리에 클래스 변수와 객체가 생성된다. StudyPlan클래스는 하나지만 new 연산자를 사용한 만큼 메모리에
객체가 생성된다. 이러한 객체들은 StudyPlan 클래스의 인스턴스들이다. 
비록 같은 클래스로부터 생성되었지만 각각의 StudyPlan 객체는 자신만의 고유 데이터를 가지면서 메모리에서 활동하게 된다.

ㅁ 클래스의 용도
1.라이브러리용(API == Application Program Interface)
 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다. 
 
2.실행용

대부분의 객체 지향 프로그램은 라이브러리(부품 객체 및 완성 객체)와 실행 클래스가 분리되어 있다.

ㅁ클래스의 구성 멤버
클래스에는 객체가 가져야 할 구성 멤버가 선언된다.
구성멤버에는 필드(Field), 생성자(Constructor), 메소드(Method) 이 구성 멤버들은 생략 되거나 복수개가 작성될 수 있다.

public class ClassOfMember {
필드Field --> 객체의 데이터가 저장되는 곳 
ex) int FiledName;

생성자Constructor --> 객체 생성 시 초기화 역할 담당 
ClassName() { }

메소드Method ---> 객체의 동작에 해당하는 실행 블록
void methodName() {}

}

필드
-> 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다. 선언 형태는 변수(Variable)와 비슷하지만, 필드를 변수라고 
   부르지 않는다. 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다. 하지만 필드는 생성자와 
   메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.
   
생성자 
-> 생성자는 new 연산자로 호출되는 특별한 중괄호{}블록이다. 생성자의 역할은 객체 생성 시 초기화를 담당한다.
   필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다. 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 
   되어 있고 리턴 타입이 없다.
   

메소드
-> 메소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말한다. 
   메소드를 호출하게 되면 중괄호 블록{}에 있는 모든 코드들이 일괄적으로 실행된다. 
   메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다. 메소드는 객체 간의 
   데이터 전달의 수단으로 사용된다. 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤값을 리턴할 수도 있다. 
   
 로컬변수 
 -> 생성자와 메소드 중괄호 블록 내부에 선언된 것은 모두 로컬 변수가 된다. 
 
 타입 
 -> 저장할 데이터의 종류를 결정한다. 
    타입에는 기본타입(byte, short, int, long, float, double, boolean)과  참조타입(배열, 클래스, 인터페이스)이 모두 올 수 있다.
    필드의 초기값은 필드 선언 시 주어질 수도 있고, 생략될수도 있다. 
    
    초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정된다. 
    
ㅁ필드 사용 
필드를 사용한다는 것은 필드값을 읽고, 변경하는 작업을 말한다. 클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 
읽고 변경하면 되지만, 클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다. 그 이유는
필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문이다.

ex)
public class Person{
 Car car = new Car(); // Car 인스턴스(객체) 생성
 car.speed = 60;// Car클래스의 car 클래스변수로 car객체 참조하여 speed라는 필드에 접근연산자로 접 변경 
}

public class Car {
int speed; // 필드

  Car() {  //생성자
   speed = 0;  //생성자에서 필드 초기값 할당  
 }

  void method() { // 메소드
   speed = 10; 
  }
}

변수는 -> 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용이 가능
필드(멤버변수) -> 생성자와 모든 메소드에서 사용이 가능하다. 
















































-----출처 : 이것이 자바다 -----
