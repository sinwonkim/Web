*클래스 선언 

public class 클래스 이름{

}
public class 키워드는 클래스를 선언할 떄 사용하며 반드시 소문자로 작성해야 한다.
클래스 이름 뒤에는 반드시 중괄호 {}를 붙여주는데, 중괄호 시작{은 클래스 선언의 시작을 알려주고 중괄호 끝}은 클래스 선언의 끝을
알려준다.

public class Car {
}

class Tire {
}
두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일은(.class)클래스를 선언한 개수만큼 생긴다.
결국 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다. 
상기 코드를 컴파일 하면 Car.class와 Tire.class가 각각 생성된다. 
주의할 점은 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다. 

* 객체 생성과 클래스 변수
클래스를 선언한 다음, 컴파일을 했다면(이클립스에서 저장) 객체를 생성할 설계도가 만들어진 셈이다.
클래스로부터 객체를 생성하는 방법은 다음과 같이 new 연산자를 사용하면 된다.
new는 클래스로부터 객체를 생성시키는 연산자이다. new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.
new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다. 
현실 세계에서의 물건의 위치를 모르면 물건을 사용할 수 없듯이, 객체 지향 프로그램에서도 메모리 내에서 생성된 객체의 위치를 모르면 
객체를 사용할 수 없다. 
그래서 new 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다. 이 주소를 참조 타입인 클래스 변수에 저장해 두면,
변수를 통해 객체를 사용할 수 있다. 
다음은 클래스 타입으로 선언된 변수에 new 연산자가 리턴한 객체의 주소를 저장한 코드이다.
ex)
클래스 변수 변수 = new 클래스();

new 연산자로 객체를 생성하고 리턴된 객체의 주소를 변수에 저장하면 변수가 객체를 참조하게 된다.


Student.java 클래스 선언  ---- 라이브러리(API)용 클래스임
public class Student {
}

StudentExample.java 클래스 선언 

public class StudentExample {
  public static void main(String[] args) {--- 실행 클래스는 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할을 함
   Student s1 = new Student(); --- Student 클래스로부터 new 키워드 사용해서 heap 영역에 인스턴스(객체) 생성 하고 
                        리턴한 객체의 주소를 s1이라는 객체의 주소를 참조하는 변수를 만들고 대입한다.
   Student s2 = new Stuudent(); s1과 s2 참조하는 Student 객체는 완전히 독립된 서로 다른 객체임 
  }
}

클래스의 용도에는 2가지가 있다.
1.라이브러리(API:Application Programming Interface)용
2.실행용

main()메소드를 작성해서 라이브러리(API)인 동시에 실행클래스로 만들 수도 있다.

public class Student{
//라이브러리로서의 코드(필드, 생성자, 메소드)

//실행하기 위한 코드
  public void main(String[] args) {
    Student s1= new Student();
    
  }
}

프로그램이 단 하나의 클래스로 구성된다면 위와 같이 작성하는 방법 umm.. is good? Most oop consist of api and Execution class.
그래서 다소 시간이 더 소요되더라도 클래스를 분리해서 작성 하는게 좋다함.

* 클래스의 구성 멤버 
클래스에는 객체가 가져야 할 구성 멤버가 선언된다.
필드(Field),
생성자(Constructor),
메소드(Method)

이 구성멤버들은 생략되거나 복수 개가 작성될 수 있다.
public class ClassName {
  // 필드 --- 객체의 데이터가 저장되는 곳 
  int fieldName; 
  
  // 생성자 -- 객체 생성 시 초기화 역할 담당
  ClassName() { 
  }
  
  // 메소드 -- 객체의 동작에 해당하는 실행 블록
  void methodName() {
  }
}

필드(Field)
필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다.
선언 형태는 변수(variable)와 비슷하지만, 필드를 변수라고 부르지 않는다. 

필드와 변수의 차이점 
변수는 생성자, 메소드 내에서만 사용되고 생성자,메소드가 실행 종료되면 자동 소멸된다.
but 필드는 생성자,메소드 전체에서 사용되면 객체가 소멸되지 않는 한 객체와 함께 존재된다.

생성자(Constructor)
생성자는 new 연산자로 호출되는 특별한 중괄호{} 블록이다. 
생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고
리턴 타입이 없다.

생성자의 역할? 
객체 생성 시 초기화를 담당한다. 
ex) 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다.

*메소드 
메소드는 객체의 동작에 해당하는 중괄호{} 블록을 말한다. 메소드 이름 관례적으로 소문자로 작성함 
메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.
메소드는 객체 간의 데이터 전달의 수단으로 사용된다.
외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있다.

메소드 선언
메소드선언은 선언부(리턴타입, 메소드이름, 매개변수선언)와 실행블록으로 구성된다. 메소드 선언부를 메소드 시그니처(signature)라고도 한다.
ex)
리턴타입 메소드이름 (매개변수선언) {
  메 소 드 실 행 블 록 
}
매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다. 
메소드 선언에 리턴타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 리턴값을 지정해야 한다. 
만약 return문이 없다면 컴파일 오류가 발생한다. return문이 실행되면 메소드는 즉시 종료된다.

메소드 호출 
메소드는 클래스 내 외부의 호출에 의해 실행된다. 클래스 내부의 다른 메소드에서 호출할 경우에는 단순한 메소드 이름으로 호출하면
되지만, 클래스 외부에서 호출할 경우에는 우선 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해서 메소드를 호출해야 한다.
그 이유는 객체가 존재해야 메소드도 존재하기 때문이다.


*필드 
타입은 필드에 저장할 데이터의 종류를 결정한다. 
타입에는
기본 타입(byte, short, int, long, float, double, boolean)과 
참조 타입(배열, 클래스(String포함), 인터페이스)이 모두 올 수 있다. 

필드 사용 
필드를 사용한다는 것은 필드값을 읽고, 변경하는 작업을 말한다. 
클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만,
클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다.
그 이유는 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문 

*생성자(Constructor)
생성자(Constructor)는 new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.

기본 생성자
모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다. 
우리가 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 다음과 같이 중괄호 {} 블록 내용이 비어있는 기본 생성자(DefaultConstructor)를 
바이트 코드에 자동 추가시킨다.

객체 외부에서 호출 
외부 클래스에서 메소드를 호출하려면  클래스로부터 객체를 생성해야 한다.
메소드는 객체에 소속된 멤버이므로 객체가 존재하지 않으면 메소드도 존재x
객체가 생성되었다면 참조 변수와 함께 도트(.) 연산자를 사용해서 메소드를 호출할 수 있다. 
도트(.) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나, 메소드에 접근할 때 사용된다.

ex)
참조변수.메소드(매개값,````); // 리턴값이 없거나, 있어도 리턴값을 받지 않을 경우
타입 변수 = 참조변수.메소드(매개값, ```); // 리턴값이 있고, 리턴값을 받고 싶을 경우 











































출처:
이것이 자바다.
